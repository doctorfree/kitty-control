#!/bin/bash
#  __ _  __  ____  ____  _  _       ___  __   __ _  ____  ____   __   __
# (  / )(  )(_  _)(_  _)( \/ )___  / __)/  \ (  ( \(_  _)(  _ \ /  \ (  )
#  )  (  )(   )(    )(   )  /(___)( (__(  O )/    /  )(   )   /(  O )/ (_/\
# (__\_)(__) (__)  (__) (__/       \___)\__/ \_)__) (__) (__\_) \__/ \____/
#
# kitty-control - control the Kitty terminal emulator from the command line
#
# Written Feb 1, 2024 by Ronald Joe Record <ronaldrecord@gmail.com>
#
VERSION=1.0.4
RELEASE=3
# The Kitty configuration directory
CONFDIR="${HOME}/.config/kitty"
[ "${KITTY_CONFIG_DIRECTORY}" ] && {
  [ -f "${KITTY_CONFIG_DIRECTORY}/kitty.conf" ] && {
    CONFDIR="${KITTY_CONFIG_DIRECTORY}"
  }
}
# The default background opacity for transparency
OPACITY="0.8"
# The socket Kitty is listening on if configured
# The format of this setting is:
#   SOCKET="--to unix:/path/to/socket"
# Leave blank if no listen socket configured
# Can be overridden with -s /path/to/socket
if [ "${KITTY_LISTEN_ON}" ]; then
    SOCKET="--to ${KITTY_LISTEN_ON}"
else
  SOCKET=
fi
# Kitty remote control options are used to specify which windows/tabs to modify
OPTS=
# Menu system vars
FONTDIR="${HOME}/.local/share/figlet-fonts"
LOLCAT="lolcat"
# Clear the screen, can be "clear" or "tput clear"
CLEAR_COMMAND="tput clear"
# Array with font names
fonts=("Fire Font-k" "Graceful" "Script" "Shadow" "Slant" "Small" "Standard")
# Font size choices for menu
fontsizes=("default" "+1" "+2" "+4" "+6" "+8" "+10" "+12" "-1" "-2" "-4" "-6" "-8" "-10" "-12")
# Fzf install script download
fzf_url="https://raw.githubusercontent.com/junegunn/fzf/master/install"
kitty_version_url="https://sw.kovidgoyal.net/kitty/current-version.txt"
# Transparency opacity choices for menu
translevels=("default" "1.0" "0.95" "0.9" "0.85" "0.8" "0.75" "0.7" "0.65" "0.6" "0.55" "0.5" "0.45" "0.4" "0.35" "0.3" "0.25" "0.2" "0.15" "0.1" "0.05" "0.0")
# Colors
colors=("reset" "black" "white" "red" "green" "yellow" "blue" "magenta" "cyan" "custom")
# Give fzf a nice look
export FZF_DEFAULT_OPTS=$FZF_DEFAULT_OPTS'
  --color=fg:#d0d0d0,fg+:#d0d0d0,bg:#0b1a38,bg+:#120f3d
  --color=hl:#5f87af,hl+:#5fd7ff,info:#afaf87,marker:#87ff00
  --color=prompt:#cadf5d,spinner:#af5fff,pointer:#af5fff,header:#87afaf
  --color=border:#5b5bab,label:#aeaeae,query:#d9d9d9
  --border="rounded" --border-label=""
  --preview-window="border-rounded"
  --prompt="ðŸ˜º Select option ("Esc" to return) ï˜½ "
  --marker=">" --pointer="â—†" --separator="â”€" --scrollbar="â”‚"
  --layout="reverse"'
# Use tput to get the bold and normal text sequence
BOLD=$(tput bold 2>/dev/null)
NORM=$(tput sgr0 2>/dev/null)

brief_usage() {
  printf "${BOLD}Usage: kitty-control [-a] [back <color>] [-c command] [dark] [-d]"
  printf "\n    [diff [opts] <path1> <path2>] [-e] [-f] [font [num]] [fore <color>]"
  printf "\n    [-i /path/to/image] [load [subdir]] [-m|t <match>] [-s /path/to/socket]"
  printf "\n    [-u|h|v] [term] [theme] [tools] [icat [opts] <image>] [list|ls [self]]"
  printf "\n    [man] [menu] [title <title>] [transparent [opacity]] [unicode] [upgrade]${NORM}"
  [ "$1" == "noexit" ] || {
    printf "\n\nWithout any arguments '${BOLD}kitty-control${NORM}'"
      printf " displays an interactive menu system"
    printf "\nFor a brief usage message run '${BOLD}kitty-control -u${NORM}'"
    printf "\nFor a full usage message run '${BOLD}kitty-control -h${NORM}'"
    printf "\nTo display several examples run '${BOLD}kitty-control -e${NORM}'\n\n"
    exit 1
  }
}

show_examples() {
  clear_screen
  if [ "${have_rich}" ]; then
    rich "[cyan]Kitty Control Examples[/cyan]" -p -a rounded -c -C
  else
    if [ "${use_figlet}" ]; then
      show_figlet "Examples"
    else
      printf "\nExample invocations of kitty-control\n"
    fi
  fi
  printf "\nTo set a transparent Kitty background with 0.9 opacity:"
  printf "\n\t${BOLD}kitty-control transparent 0.9${NORM}"
  printf "\nTo set the Kitty background to fully opaque (no transparency):"
  printf "\n\t${BOLD}kitty-control dark${NORM}"
  printf "\nTo set the Kitty background color to black and foreground color to white:"
  printf "\n\t${BOLD}kitty-control back black fore white${NORM}"
  printf "\nTo load the Kitty config in ~/.config/kitty/laptop/kitty.conf"
  printf "\n\t${BOLD}kitty-control load laptop${NORM}"
  printf "\nTo increase the font size by 2 points:"
  printf "\n\t${BOLD}kitty-control font +2${NORM}"
  printf "\nTo set the background image to ~/Pictures/groovy.png"
  printf "\n\t${BOLD}kitty-control -i ~/Pictures/groovy.png${NORM}"
  printf "\nActions can be combined on the same command line:"
  printf "\n\t${BOLD}kitty-control -i ~/Pictures/groovy.png fore cyan font 24${NORM}"
  printf "\nTo view the image ~/Pictures/cats.png"
  printf "\n\t${BOLD}kitty-control icat ~/Pictures/cats.png${NORM}"
  printf "\nTo view differences between /path/to/file1 and /path/to/file2"
  printf "\n\t${BOLD}kitty-control diff /path/to/file1 /path/to/file2${NORM}"
  printf "\nTo set the tab title of the tab currently titled '~/src/borg' to 'Borg Backup':"
  printf "\n\t${BOLD}kitty-control -m \"title:borg\" title \"Borg Backup\"${NORM}"
  printf "\nTo restore the original Kitty configuration:"
  printf "\n\t${BOLD}kitty-control load default${NORM}"
  printf "\n\nWithout any arguments '${BOLD}kitty-control${NORM}'"
    printf " displays an interactive menu system\n"
  [ "$1" == "noexit" ] || exit 1
}

usage() {
  brief_usage noexit
  printf "\nWhere:"
  printf "\n    '${BOLD}back color${NORM}' Sets the background color to 'color'"
  printf "\n           If 'color' is 'reset' restores foreground and background to startup value"
  printf "\n    '${BOLD}dark${NORM}' Sets the Kitty background opacity to 1.0 (fully opaque)"
  printf "\n           Can use 'dark' or 'opaque'"
  printf "\n    '${BOLD}diff [opts] <file1|dir1> <file2|dir2>${NORM}'"
    printf " Displays differences using the 'diff' kitten"
  printf "\n           Enclose [opts] and <file1/dir1> in quotes if [opts] are provided"
  printf "\n           See https://sw.kovidgoyal.net/kitty/kittens/diff/#options"
  printf "\n    '${BOLD}font num${NORM}' Sets the font pointsize to 'num'"
  printf "\n           Can use 'font', 'fontsize', 'fontminus', or 'fontplus'"
  printf "\n           The second argument specifies the font size, either absolute, +, or -"
  printf "\n           e.g. 'kitty-control fontsize 24' would set the font size to 24 points"
  printf "\n                'kitty-control font +2' would increase the font size by 2 points"
  printf "\n                'kitty-control font' without argument resets the font size to default"
  printf "\n    '${BOLD}fore color${NORM}' Sets the foreground color to 'color'"
  printf "\n           If 'color' is 'reset' restores foreground and background to startup value"
  printf "\n    '${BOLD}icat [opts] <image>${NORM}' Displays <image> using the Kitty 'icat' kitten"
  printf "\n           Enclose [opts] and <image> in quotes if [opts] are provided"
  printf "\n           To remove all images currently displayed on the screen:"
  printf "\n               kitty-control icat --clear"
  printf "\n           See https://sw.kovidgoyal.net/kitty/kittens/icat/#options"
  printf "\n    '${BOLD}list [self]${NORM}' Displays full information on Kitty windows"
  [ "${have_jq}" ] && {
    printf "\n    '${BOLD}ls [self]${NORM}' Displays the id, title, pid, and state of Kitty windows"
  }
  printf "\n    '${BOLD}load [subdir]${NORM}'"
    printf " Reloads the Kitty configuration in ~/.config/kitty/kitty.conf"
  printf "\n           Can use 'load' or 'reload'"
  printf "\n           Specify a second argument to load ~/.config/kitty/<subdir>/kitty.conf"
  printf "\n           e.g. 'kitty-control load tv' would load ~/.config/kitty/tv/kitty.conf"
  printf "\n           'kitty-control load default' loads the ~/.config/kitty/kitty.conf config"
  printf "\n           'kitty-control load --help' displays a help message for the load command"
  printf "\n    '${BOLD}man${NORM}' Displays the kitty-control manual"
  printf "\n    '${BOLD}menu${NORM}' Displays the kitty-control interactive menu system"
  printf "\n    '${BOLD}term${NORM}'"
    printf " Displays information about the terminal using the query_terminal kitten"
  printf "\n    '${BOLD}theme${NORM}' Displays the interactive theme selection kitten"
  printf "\n    '${BOLD}title <tab title>${NORM}' Sets the Kitty tab title to \"tab title\""
  printf "\n          Quote tab titles which contain spaces, e.g. \"This Is My Tab Title\""
  printf "\n          Use '-m <match>' to specify the tab to match"
  printf "\n    '${BOLD}tools${NORM}' Installs 'figlet' and 'ranger' if not already present"
  printf "\n    '${BOLD}tran [opacity]${NORM}' Sets the Kitty background opacity to 0.8"
  printf "\n           Can use 'tran', 'opacity', 'trans' or 'transparent'"
  printf "\n           Specify a second argument to set a custom background opacity:"
  printf "\n           e.g. 'kitty-control transparent 0.9'"
  printf "\n    '${BOLD}unicode${NORM}' Displays the Unicode input kitten"
  printf "\n    '${BOLD}upgrade${NORM}' Upgrades Kitty, Fzf, and kitty-control to the latest version"
  printf "\n    '${BOLD}-a${NORM}'"
    printf " Indicates modify all windows rather than just the currently active OS window"
  printf "\n    '${BOLD}-c command${NORM}'"
    printf " specifies a Kitty command to run (enclose command and arguments in quotes)"
  printf "\n        Can be used to run arbitrary commands, e.g. 'kitty-control -c get-colors'"
  printf "\n    '${BOLD}-d${NORM}' Debug mode - display commands when executed"
  printf "\n    '${BOLD}-e${NORM}' Displays several example invocations and exits"
  printf "\n    '${BOLD}-f${NORM}' Indicates toggle fullscreen"
  printf "\n    '${BOLD}-h${NORM}' Displays a full usage message and exits"
  printf "\n    '${BOLD}-i /path/to/image${NORM}'"
    printf " sets the background image for the specified Kitty windows"
  printf "\n        If /path/to/image is 'none' then any existing image will be removed"
  printf "\n    '${BOLD}-m <match>${NORM}' Specifies the window to match"
  printf "\n    '${BOLD}-t <match>${NORM}' Specifies the tab to match"
  printf "\n        Window/Tab matching can be used in conjunction with most kitty-control commands"
  printf "\n        If <match> is '--help' the Kitty documentation URL for matching will be displayed"
  printf "\n    '${BOLD}-s /path/to/socket${NORM}'"
    printf " Specifies the socket Kitty is listening on if enabled"
  printf "\n        If /path/to/socket is '--help' some help on configuring a Kitty socket is provided"
  printf "\n        '-s /path/...' can be used to send commands to Kitty from another terminal"
  printf "\n    '${BOLD}-u${NORM}' Displays a brief usage message and exits"
  printf "\n    '${BOLD}-v${NORM}' Displays the kitty-control and kitty versions then exits"
  printf "\n\nWithout any arguments '${BOLD}kitty-control${NORM}'"
    printf " displays an interactive menu system"
  printf "\nAdjusting the background opacity or font size requires the original kitty.conf"
  printf "\nthat was used for this instance of Kitty to have enabled the following:"
  printf "\n    '${BOLD}dynamic_background_opacity yes${NORM}'"
    printf " and '${BOLD}allow_remote_control yes${NORM}'"
  printf "\nSee https://sw.kovidgoyal.net/kitty/remote-control/#control-kitty-from-scripts\n"
  [ "$1" == "examples" ] && show_examples
  [ "$1" == "noexit" ] || exit 1
}

clear_screen() {
  [ "${debug}" ] || ${CLEAR_COMMAND}
}

pathadd() {
  if [ -d "$1" ] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="$1${PATH:+":$PATH"}"
    export PATH
  fi
}

prompt_continue() {
  printf "\nPress <Enter> to continue ... "
  read -r yn
}

set_show_shortcuts() {
  if [ "${have_fzf}" ]; then
    shortcuts="bg/back c/clear d/dark F/full f/font fg/fore fzf/fuzzy h/help i/info"
  else
    shortcuts="bg/back c/clear d/dark F/full f/font fg/fore h/help i/info"
  fi
  addtlcuts="K/list tabs L/list windows l/load o/opts q/quit T/theme t/tran v/view"
  if [ "${have_rich}" ]; then
    rich "[b cyan]Shortcuts:[/] [b yellow]${shortcuts}[/]" -p
    rich "           [b yellow]${addtlcuts}[/]" -p
  else
    printf "\nShortcuts: ${BOLD}${shortcuts}${NORM}"
    printf "\n           ${BOLD}${addtlcuts}${NORM}\n"
  fi
}

show_help() {
  clear_screen
  if [ "${have_rich}" ]; then
    rich "[cyan]Kitty Control Menu Help[/cyan]" -p -a rounded -c -C
    rich "[green]Control kitty from a menu system[/green]" -p -c
  else
    printf "\n\tKitty Control Menu Help\n"
    printf "\n\tControl kitty from a menu system\n"
  fi
  printf "\nEnter a menu option number or shortcut to select an option.\n\n"
  set_show_shortcuts
  printf "\nIn the fuzzy selection dialogs, enter a few letters to fuzzy select from the options\n"
  if [ "${have_rich}" ]; then
    rich "or use the [magenta]<Up-Arrow>[/] and [magenta]<Down-Arrow>[/] keys to move through the options." -p
    rich "Press [magenta]<Enter>[/] to select the highlighted option." -p
  else
    printf "or use the <Up-Arrow> and <Down-Arrow> keys to move through the options."
    printf "\nPress <Enter> to select the highlighted option.\n"
  fi
  printf "\nNot all actions are available from the interactive menu interface.\n"
  printf "\nKitty Control can also be used from the command line.\n"
  if [ "${have_rich}" ]; then
    rich "See: [cyan]kitty-control -h[/] for full usage details" -p
  else
    printf "${BOLD}${LINE}See:${NORM} ${BOLD}kitty-control -h${NORM} for full usage details\n"
  fi
  prompt_continue
}

get_control_version() {
  VTOP="https://raw.githubusercontent.com/doctorfree/kitty-control"
  VURL="${VTOP}/main/VERSION"
  curl -fsSL "${VURL}" > /tmp/kcv$$
  kcver=$(cat /tmp/kcv$$ | grep VERSION | awk -F '=' '{ print $2 }')
  kcrel=$(cat /tmp/kcv$$ | grep RELEASE | awk -F '=' '{ print $2 }')
  rm -f /tmp/kcv$$
  echo "v${kcver}r${kcrel}"
}

get_install_version() {
  KC_INST="${HOME}/.local/bin/kitty-control"
  if [ -f ${KC_INST} ]; then
    kcver=$(grep ^VERSION= ${KC_INST} | awk -F '=' '{ print $2 }')
    kcrel=$(grep ^RELEASE= ${KC_INST} | awk -F '=' '{ print $2 }')
  else
    kcver=${VERSION}
    kcrel=${RELEASE}
  fi
  echo "v${kcver}r${kcrel}"
}

# check_three_version release_version install_version
check_three_version() {
  release_version="$1"
  install_version="$2"

  release_major=$(echo ${release_version} | awk -F '.' '{ print $1 }')
  release_midde=$(echo ${release_version} | awk -F '.' '{ print $2 }')
  release_minor=$(echo ${release_version} | awk -F '.' '{ print $3 }')
  [ "${release_major}" ] || release_major=0
  [ "${release_midde}" ] || release_midde=0
  [ "${release_minor}" ] || release_minor=0

  install_major=$(echo ${install_version} | awk -F '.' '{ print $1 }')
  install_midde=$(echo ${install_version} | awk -F '.' '{ print $2 }')
  install_minor=$(echo ${install_version} | awk -F '.' '{ print $3 }')
  [ "${install_major}" ] || install_major=0
  [ "${install_midde}" ] || install_midde=0
  [ "${install_minor}" ] || install_minor=0

  if [ ${release_major} -gt ${install_major} ]; then
    echo "${release_version}"
  else
    if [ ${release_midde} -gt ${install_midde} ]; then
      echo "${release_version}"
    else
      if [ ${release_minor} -gt ${install_minor} ]; then
        echo "${release_version}"
      else
        echo ""
      fi
    fi
  fi
}

# check_control_version release_version install_version
check_control_version() {
  release_version=$(echo $1 | awk -F 'r' '{ print $1 }' | sed -e "s/v//")
  release_release=$(echo $1 | awk -F 'r' '{ print $2 }')
  install_version=$(echo $2 | awk -F 'r' '{ print $1 }' | sed -e "s/v//")
  install_release=$(echo $2 | awk -F 'r' '{ print $2 }')
  release_major=$(echo ${release_version} | awk -F '.' '{ print $1 }')
  release_midde=$(echo ${release_version} | awk -F '.' '{ print $2 }')
  release_minor=$(echo ${release_version} | awk -F '.' '{ print $3 }')
  [ "${release_major}" ] || release_major=0
  [ "${release_midde}" ] || release_midde=0
  [ "${release_minor}" ] || release_minor=0
  [ "${release_release}" ] || release_release=0
  install_major=$(echo ${install_version} | awk -F '.' '{ print $1 }')
  install_midde=$(echo ${install_version} | awk -F '.' '{ print $2 }')
  install_minor=$(echo ${install_version} | awk -F '.' '{ print $3 }')
  [ "${install_major}" ] || install_major=0
  [ "${install_midde}" ] || install_midde=0
  [ "${install_minor}" ] || install_minor=0
  [ "${install_release}" ] || install_release=0
  if [ ${release_major} -gt ${install_major} ]; then
    echo "${release_version}"
  else
    if [ ${release_midde} -gt ${install_midde} ]; then
      echo "${release_version}"
    else
      if [ ${release_minor} -gt ${install_minor} ]; then
        echo "${release_version}"
      else
        if [ ${release_release} -gt ${install_release} ]; then
          echo "${release_version}"
        else
          echo ""
        fi
      fi
    fi
  fi
}

show_versions() {
  printf "\n"
  control_version=$(get_control_version)
  install_version=$(get_install_version)
  if [ "${have_rich}" ]; then
    if [ "${install_version}" == "${control_version}" ]; then
      rich "Installed [green]kitty-control[/] version: [yellow]${install_version}[/] (îª² current)" -p
    else
      rich "Installed [green]kitty-control[/] version: [yellow]${install_version}[/]" -p
      rich "Available [green]kitty-control[/] version: [yellow]${control_version}[/]" -p
    fi
  else
    printf "\nInstalled kitty-control version: ${install_version}"
    if [ "${install_version}" == "${control_version}" ]; then
      printf " (îª² current)"
    else
      printf "\nAvailable kitty-control version: ${control_version}"
    fi
  fi
  release_version=$(curl -fsSL "${kitty_version_url}")
  install_version=$(kitty --version | awk '{ print $2 }')
  if [ "${have_rich}" ]; then
    if [ "${install_version}" == "${release_version}" ]; then
      rich "Installed [green]kitty[/] version: [yellow]${install_version}[/] (îª² current)" -p
    else
      rich "Installed [green]kitty[/] version: [yellow]${install_version}[/]" -p
      rich "Available [green]kitty[/] version: [yellow]${release_version}[/]" -p
    fi
  else
    printf "\nInstalled kitty version: ${install_version}"
    if [ "${install_version}" == "${release_version}" ]; then
      printf " (îª² current)\n\n"
    else
      printf "\nAvailable kitty version: ${release_version}\n\n"
    fi
  fi
  release_version=$(curl -fsSL "${fzf_url}" | grep ^version= | awk -F '=' '{ print $2 }')
  if [ "${have_fzf}" ]; then
    install_version=$(fzf --version | awk '{ print $1 }')
  else
    install_version="uninstalled"
  fi
  if [ "${have_rich}" ]; then
    if [ "${install_version}" == "${release_version}" ]; then
      rich "Installed [green]fzf[/] version: [yellow]${install_version}[/] (îª² current)" -p
    else
      rich "Installed [green]fzf[/] version: [yellow]${install_version}[/]" -p
      rich "Available [green]fzf[/] version: [yellow]${release_version}[/]" -p
    fi
  else
    printf "\nInstalled fzf version: ${install_version}"
    if [ "${install_version}" == "${release_version}" ]; then
      printf " (îª² current)\n"
    else
      printf "\nAvailable fzf version: ${release_version}\n"
    fi
  fi
  printf "\n"
}

install_figlet() {
  have_make=$(type -p make)
  if [ "${have_make}" ]; then
    HERE=$(pwd)
    git clone https://github.com/cmatsuoka/figlet /tmp/figlet$$ >/dev/null 2>&1
    cd /tmp/figlet$$
    ${SUDO} make install >/dev/null 2>&1
    cd "${HERE}"
    ${SUDO} rm -rf /tmp/figlet$$
    have_figlet=$(type -p figlet)
    [ "${have_figlet}" ] && use_figlet=1
  else
    printf "\nInstallation of figlet requires 'make' but 'make' not found."
    printf "\nInstall 'make' and try again. Skipping installation of figlet.\n"
    prompt_continue
  fi
}

install_fzf() {
  [ -d ${HOME}/.fzf ] && mv ${HOME}/.fzf ${HOME}/.fzf$$
  git clone --depth 1 https://github.com/junegunn/fzf.git \
    ${HOME}/.fzf >/dev/null 2>&1
  [ -f ${HOME}/.fzf/install ] && chmod 755 ${HOME}/.fzf/install
  [ -x ${HOME}/.fzf/install ] && ${HOME}/.fzf/install --all >/dev/null 2>&1
  [ -d ${HOME}/.fzf/bin ] && pathadd "${HOME}/.fzf/bin"
  have_fzf=$(type -p fzf)
  [ "${have_fzf}" ] && use_fzf=1
}

install_ranger() {
  have_make=$(type -p make)
  if [ "${have_make}" ]; then
    HERE=$(pwd)
    git clone https://github.com/ranger/ranger /tmp/ranger$$ >/dev/null 2>&1
    cd /tmp/ranger$$
    git checkout stable >/dev/null 2>&1
    ${SUDO} make install >/dev/null 2>&1
    cd "${HERE}"
    ${SUDO} rm -rf /tmp/ranger$$
    have_ranger=$(type -p ranger)
    [ "${have_ranger}" ] && use_ranger=1
    [ -d ${HOME}/.config ] || mkdir -p ${HOME}/.config
    [ -d ${HOME}/.config/ranger ] && {
      mv ${HOME}/.config/ranger ${HOME}/.config/ranger.bak$$
    }
    git clone https://github.com/doctorfree/ranger \
              ${HOME}/.config/ranger >/dev/null 2>&1
    rm -rf ${HOME}/.config/ranger/.git
    [ -f ${HOME}/.config/ranger/scope.sh ] && {
      chmod 755 ${HOME}/.config/ranger/scope.sh
    }
    [ -d ${HOME}/.config/ranger.bak$$ ] && {
      diff -srq ${HOME}/.config/ranger.bak$$ \
                ${HOME}/.config/ranger \
        | grep identical | grep ^File \
        | while read dupline
          do
            dup=$(echo "${dupline}" | awk '{ print $2 }')
            rm -f "${dup}"
          done
      for plugindir in ${HOME}/.config/ranger.bak$$/plugins/*
      do
        [ "${plugindir}" == "${HOME}/.config/ranger.bak$$/plugins/*" ] && continue
        rmdir --ignore-fail-on-non-empty "${plugindir}"
      done
      rmdir --ignore-fail-on-non-empty ${HOME}/.config/ranger.bak$$/plugins
      rmdir --ignore-fail-on-non-empty ${HOME}/.config/ranger.bak$$
    }
  else
    printf "\nInstallation of ranger requires 'make' but 'make' not found."
    printf "\nInstall 'make' and try again. Skipping installation of ranger.\n"
    prompt_continue
  fi
}

kitty-fontminus() {
  size="$1"
  first_size=${size::1}
  if [[ "${first_size}" == "-" ]]; then
    kitty @ ${SOCKET} set-font-size ${OPTS} -- $size
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-font-size ${OPTS} -- $size\n"
      prompt_continue
    }
  else
    kitty @ ${SOCKET} set-font-size ${OPTS} -- -$size
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-font-size ${OPTS} -- -$size\n"
      prompt_continue
    }
  fi
}

kitty-fontplus() {
  size="$1"
  first_size=${size::1}
  if [[ "${first_size}" == "+" ]]; then
    kitty @ ${SOCKET} set-font-size ${OPTS} $size
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-font-size ${OPTS} $size\n"
      prompt_continue
    }
  else
    kitty @ ${SOCKET} set-font-size ${OPTS} +$size
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-font-size ${OPTS} +$size\n"
      prompt_continue
    }
  fi
}

kitty-fontsize() {
  size="$1"
  first_size=${size::1}
  if [[ "${first_size}" == "-" ]]; then
    kitty @ ${SOCKET} set-font-size ${OPTS} -- $size
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-font-size ${OPTS} -- $size\n"
      prompt_continue
    }
  else
    kitty @ ${SOCKET} set-font-size ${OPTS} $size
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-font-size ${OPTS} $size\n"
      prompt_continue
    }
  fi
}

load-config() {
  if [ "$1" == "--help" ]; then
    printf "\nThe 'kitty-control load <subdir>' command loads the Kitty configuration"
    printf "\nfile in '~/.config/kitty/<subdir>/kitty.conf'. The current instance of"
    printf "\nkitty continues to run and the specified configuration file is loaded."
    printf "\nAll tabs and state are preserved while the new configuration is loaded."
    printf "\n\nThe new Kitty configuration file must be prepared beforehand and located"
    printf "\nin the specified subdirectory in the Kitty configuration folder."
    printf "\n\nFor example, if you have one Kitty configuration used for a large screen"
    printf "\nTV and another used for a laptop then placing the TV Kitty configuration"
    printf "\nin ~/.config/kitty/tv/kitty.conf and the laptop Kitty configuration in"
    printf "\n~/.config/kitty/laptop/kitty.conf would allow you to switch between these"
    printf "\ntwo Kitty configurations with kitty-control as follows:"
    printf "\n\tkitty-control load tv # When your display is the TV as monitor"
    printf "\n\tkitty-control load laptop # When you're using the laptop built-in display"
    printf "\n\nTo restore the Kitty configuration in ~/.config/kitty/kitty.conf:"
    printf "\n\tkitty-control load default\n\n"
    exit 0
  else
    kcfg="$1/kitty.conf"
    [ "$1" == "default" ] && kcfg="kitty.conf"
    if [ -f "${CONFDIR}/${kcfg}" ]; then
      if [ "${USE_LOAD_CONFIG}" ]; then
        kitty @ ${SOCKET} load-config-file "${CONFDIR}/${kcfg}"
        [ "${debug}" ] && {
          printf "\nDEBUG: kitty @ ${SOCKET} load-config-file ${CONFDIR}/${kcfg}"
          prompt_continue
        }
      else
        kitty @ ${SOCKET} kitten read_config.py "${CONFDIR}/${kcfg}"
        [ "${debug}" ] && {
          printf "\nDEBUG: kitty @ ${SOCKET} kitten read_config.py ${CONFDIR}/${kcfg}"
          prompt_continue
        }
      fi
    else
      if [ "$2" ] && [ -f "${CONFDIR}/$2/kitty.conf" ]; then
        kcfg="$2/kitty.conf"
        if [ "${USE_LOAD_CONFIG}" ]; then
          kitty @ ${SOCKET} load-config-file "${CONFDIR}/${kcfg}"
          [ "${debug}" ] && {
            printf "\nDEBUG: kitty @ ${SOCKET} load-config-file ${CONFDIR}/${kcfg}"
            prompt_continue
          }
        else
          kitty @ ${SOCKET} kitten read_config.py "${CONFDIR}/${kcfg}"
          [ "${debug}" ] && {
            printf "\nDEBUG: kitty @ ${SOCKET} kitten read_config.py ${CONFDIR}/${kcfg}"
            prompt_continue
          }
        fi
      else
        printf "\n ${CONFDIR}/${kcfg} does not exist or is not a regular file\n"
        prompt_continue
      fi
    fi
  fi
}

# colorize man pages
# man() {
#   LESS_TERMCAP_mb=$'\e[01;31m' \
#     LESS_TERMCAP_md=$'\e[01;35m' \
#     LESS_TERMCAP_me=$'\e[0m' \
#     LESS_TERMCAP_se=$'\e[0m' \
#     LESS_TERMCAP_so=$'\e[01;33m' \
#     LESS_TERMCAP_ue=$'\e[0m' \
#     LESS_TERMCAP_us=$'\e[04;36m' \
#     command man "$@"
# }
# Using tput
man() {
  LESS_TERMCAP_md=$(tput bold; tput setaf 6) \
    LESS_TERMCAP_me=$(tput sgr0) \
    LESS_TERMCAP_so=$(tput bold; tput setaf 3; tput setab 57) \
    LESS_TERMCAP_se=$(tput rmso; tput sgr0) \
    LESS_TERMCAP_us=$(tput smul; tput bold; tput setaf 4) \
    LESS_TERMCAP_ue=$(tput rmul; tput sgr0) \
    LESS_TERMCAP_mr=$(tput rev) \
    LESS_TERMCAP_mh=$(tput dim) \
    command man "$@"
}

set-bg-image() {
  image="$1"
  if [ "${image}" == "none" ]; then
    kitty @ ${SOCKET} set-background-image --no-response ${OPTS} none
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-background-image --no-response ${OPTS} none\n"
      prompt_continue
    }
  else
    if [ -f "${image}" ]; then
      kitty @ ${SOCKET} set-background-image --layout scaled ${OPTS} "${image}"
    [ "${debug}" ] && {
        printf "\nDEBUG: kitty @ ${SOCKET} set-background-image --layout scaled ${OPTS} ${image}"
      prompt_continue
    }
    else
      printf "\nSpecified Kitty background image ${image} not found\n"
      prompt_continue
    fi
  fi
}

set-background() {
  if [ "$1" == "reset" ]; then
    kitty @ ${SOCKET} set-colors ${OPTS} --reset
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-colors ${OPTS} --reset\n"
      prompt_continue
    }
  else
    kitty @ ${SOCKET} set-colors ${OPTS} background=$1 tab_bar_background=$1
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-colors ${OPTS} background=$1 tab_bar_background=$1\n"
      prompt_continue
    }
  fi
}

set-foreground() {
  if [ "$1" == "reset" ]; then
    kitty @ ${SOCKET} set-colors ${OPTS} --reset
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-colors ${OPTS} --reset\n"
      prompt_continue
    }
  else
    kitty @ ${SOCKET} set-colors ${OPTS} foreground=$1
    [ "${debug}" ] && {
      printf "\nDEBUG: kitty @ ${SOCKET} set-colors ${OPTS} foreground=$1\n"
      prompt_continue
    }
  fi
}

set-opacity() {
  kitty @ ${SOCKET} set-background-opacity ${OPTS} $1
    [ "${debug}" ] && {
    printf "\nDEBUG: kitty @ ${SOCKET} set-background-opacity ${OPTS} $1\n"
      prompt_continue
    }
}

toggle-fullscreen() {
  kitty @ ${SOCKET} resize-os-window --action toggle-fullscreen ${OPTS}
    [ "${debug}" ] && {
    printf "\nDEBUG: kitty @ ${SOCKET} resize-os-window --action toggle-fullscreen ${OPTS}\n"
      prompt_continue
    }
}

install_kitty() {
  darwin=
  platform=$(uname -s)
  [ "${platform}" == "Darwin" ] && darwin=1
  if [ "${darwin}" ]; then
    LOCAL="/Applications/kitty.app/Contents"
    KBIN="${LOCAL}/MacOS"
    KTINFO="${LOCAL}/Resources/kitty/terminfo/kitty.terminfo"
    KXTERM="${LOCAL}/Resources/kitty/terminfo/78/xterm-kitty"
    KSTERM="${LOCAL}/Resources/terminfo/78/xterm-kitty"
  else
    LOCAL="${HOME}/.local/kitty.app"
    KBIN="${LOCAL}/bin"
    KTINFO="${LOCAL}/lib/kitty/terminfo/kitty.terminfo"
    KXTERM="${LOCAL}/lib/kitty/terminfo/x/xterm-kitty"
    KSTERM="${LOCAL}/share/terminfo/x/xterm-kitty"
  fi
  printf "\n\tInstalling/Upgrading Kitty terminal emulator ..."
  installer_url="https://sw.kovidgoyal.net/kitty/installer.sh"
  curl --silent --location ${installer_url} >/tmp/kitty-$$.sh
  [ $? -eq 0 ] || {
    rm -f /tmp/kitty-$$.sh
    curl --insecure --silent --location ${installer_url} >/tmp/kitty-$$.sh
    cat /tmp/kitty-$$.sh | sed -e "s/curl -/curl -k/" >/tmp/k$$
    cp /tmp/k$$ /tmp/kitty-$$.sh
    rm -f /tmp/k$$
  }
  if [ -s /tmp/kitty-$$.sh ]; then
    sh /tmp/kitty-$$.sh launch=n >/dev/null 2>&1
    rm -f /tmp/kitty-$$.sh
    # Create a symbolic link to add kitty to PATH
    [ -d ~/.local/bin ] || mkdir -p ~/.local/bin
    if [ -x ${KBIN}/kitty ]; then
      [ -x ~/.local/bin/kitty ] || {
        ln -s ${KBIN}/kitty ~/.local/bin/
      }
    else
      printf "\nUnable to create Kitty link to ~/.local/bin/\n"
    fi
    if [ -x ~/${KBIN}/kitten ]; then
      [ -x ~/.local/bin/kitten ] || {
        ln -s ~/${KBIN}/kitten ~/.local/bin/
      }
    else
      printf "\nUnable to create kitten link to ~/.local/bin/\n"
    fi
    # Link the kitty man pages somewhere it can be found by the man command
    if [ "${darwin}" ]; then
      LINMAN="/Applications/kitty.app/Contents/Resources/man"
    else
      LINMAN="${LOCAL}/share/man"
    fi
    [ -d ~/.local/share/man/man1 ] || mkdir -p ~/.local/share/man/man1
    [ -f ~/.local/share/man/man1/kitty.1 ] || {
      [ -d ${HOME}/.local/share/man/man1 ] || {
        mkdir -p ${HOME}/.local/share/man/man1
      }
      [ -f "${LINMAN}/man1/kitty.1" ] && {
        ln -s "${LINMAN}/man1/kitty.1" ~/.local/share/man/man1/
      }
    }
    [ -d ~/.local/share/man/man5 ] || mkdir -p ~/.local/share/man/man5
    [ -f ~/.local/share/man/man5/kitty.conf.5 ] || {
      [ -d ${HOME}/.local/share/man/man5 ] || {
        mkdir -p ${HOME}/.local/share/man/man5
      }
      [ -f "${LINMAN}/man5/kitty.conf.5" ] && {
        ln -s "${LINMAN}/man5/kitty.conf.5" ~/.local/share/man/man5/
      }
    }
    # Place the kitty.desktop file somewhere it can be found by the OS
    [ -d ~/.local/share/applications ] || mkdir -p ~/.local/share/applications
    [ -f "${LOCAL}/share/applications/kitty.desktop" ] && {
      [ -f ~/.local/share/applications/kitty.desktop ] || {
        cp ${LOCAL}/share/applications/kitty.desktop \
          ~/.local/share/applications/
      }
    }
    # If you want to open text files and images in kitty via your file manager
    # also add the kitty-open.desktop file
    [ -f "${LOCAL}/share/applications/kitty-open.desktop" ] && {
      [ -f ~/.local/share/applications/kitty-open.desktop ] || {
        cp ${LOCAL}/share/applications/kitty-open.desktop \
          ~/.local/share/applications/
      }
    }
    # Update the paths to the kitty and its icon in the kitty.desktop file(s)
    for desktop in "${HOME}"/.local/share/applications/kitty*.desktop; do
      [ "${desktop}" == "${HOME}/.local/share/applications/kitty*.desktop" ] && continue
      [ -f ${LOCAL}/share/icons/hicolor/256x256/apps/kitty.png ] && {
        sed -i "s|Icon=kitty|Icon=${LOCAL}/share/icons/hicolor/256x256/apps/kitty.png|g" "${desktop}"
      }
      [ -x ${LOCAL}/bin/kitty ] && {
        sed -i "s|Exec=kitty|Exec=${LOCAL}/bin/kitty|g" "${desktop}"
      }
    done
    printf " done!\n"
  else
    printf "\n${BOLD}ERROR:${NORM} Download of kitty installation script failed"
    printf "\nSee https://sw.kovidgoyal.net/kitty/binary/#manually-installing"
    printf "\nto manually install the kitty terminal emulator\n"
  fi

  # Install the Kitty terminfo entry
  KITERM="${HOME}/.terminfo/x/xterm-kitty"
  MATERM="${HOME}/.terminfo/78/xterm-kitty"
  [ -f "${KITERM}" ] || [ -f "${MATERM}" ] || {
    [ -d ${HOME}/.terminfo ] || mkdir -p ${HOME}/.terminfo
    [ -d ${HOME}/.terminfo/x ] || mkdir -p ${HOME}/.terminfo/x
    [ -d ${HOME}/.terminfo/78 ] || mkdir -p ${HOME}/.terminfo/78
    have_tic=$(type -p tic)
    [ "${have_tic}" ] && {
      [ -f "${KTINFO}" ] && {
        tic -x -o ${HOME}/.terminfo "${KTINFO}" >/dev/null 2>&1
      }
    }
    [ -f "${KITERM}" ] || [ -f "${MATERM}" ] || {
      if [ -f "${KXTERM}" ]; then
        cp "${KXTERM}" "${KITERM}"
      else
        if [ -f "${KSTERM}" ]; then
          cp "${KSTERM}" "${KITERM}"
        else
          printf "\nUnable to create Kitty terminfo entry ${KITERM}\n"
        fi
      fi
    }
  }
}

upgrade_fzf() {
  [ -d ${HOME}/.fzf/.git ] && git -C ${HOME}/.fzf pull >/dev/null 2>&1
  if [ -d ${HOME}/.fzf ]; then
    if [ -f ${HOME}/.fzf/install ]; then
      chmod 755 ${HOME}/.fzf/install
      ${HOME}/.fzf/install --all >/dev/null 2>&1
    else
      install_fzf
    fi
  else
    have_brew=$(type -p brew)
    [ "${have_brew}" ] && brew uninstall fzf >/dev/null 2>&1
    install_fzf
  fi
  [ -d ${HOME}/.fzf/bin ] && pathadd "${HOME}/.fzf/bin"
}

upgrade_kitty_control() {
  KC_REPO="https://github.com/doctorfree/kitty-control"
  git clone ${KC_REPO} /tmp/kctmp$$ >/dev/null 2>&1
  [ -f /tmp/kctmp$$/install ] || {
    rm -rf /tmp/kctmp$$
    printf "\nERROR: unable to download kitty-control repository\n"
    if [ "$1" == "noexit" ]; then
      prompt_continue
    else
      exit 1
    fi
  }
  chmod 755 /tmp/kctmp$$/install
  /tmp/kctmp$$/install
  rm -rf /tmp/kctmp$$
  install_version=$(get_install_version)
  VERSION=$(echo ${install_version} | awk -F 'r' '{ print $1 }' | sed -e "s/v//")
  RELEASE=$(echo ${install_version} | awk -F 'r' '{ print $2 }')
}

heading() {
  clear_screen
  if [ "${have_rich}" ]; then
    rich "[cyan]$1[/cyan]" -p -a rounded -c -C
  else
    if [ "${use_figlet}" ]; then
      show_figlet "$2"
    else
      printf "\nSelect $1\n"
    fi
  fi
  printf "\n"
}

choose_file() {
  TMP="$(mktemp)"
  ranger --choosefile="${TMP}" "${HOME}" 1>&2
  cat ${TMP}
  rm -f ${TMP}
}

choose_folder() {
  TMP="$(mktemp)"
  ranger --choosedir="${TMP}" "${HOME}" 1>&2
  cat ${TMP}
  rm -f ${TMP}
}

select_file() {
  # Can be called with e.g. 'select_file image' to use 'image' as file type
  # If no argument is passed then any file will do
  keyword=
  selectedFile=
  [ "$1" ] && keyword="$1"
  if [ "${use_ranger}" ]; then
    selectedFile="$(choose_file)"
  else
#   selectedFile=$(dialog --stdout --title "Please select a file" --fselect ${HOME} 0 0)
    printf "\nEnter the path to a file\n"
    while true; do
      read -r -p "Enter file path ('q' to exit): " filepath
      [ "${filepath}" == "q" ] && break
      if [ -f "${filepath}" ]; then
        selectedFile="${filepath}"
        break
      else
        if [ "${filepath}" ]; then
          printf "Specified file ${filepath} does not exist or is not a plain file."
        else
          printf "\nEmpty file path entered."
        fi
        printf "\nPlease enter a valid file path or 'q' to exit this dialog.\n"
      fi
    done
  fi
  if [ "${selectedFile}" ]; then
    if [ "${keyword}" ]; then
      thisfile=
      file -L "${selectedFile}" | grep -i "${keyword}" >/dev/null && thisfile=1
    else
      thisfile=1
    fi
    [ "${thisfile}" ] && FILE="${selectedFile}"
  else
    FILE=
  fi
}

select_folder() {
  FOLD=
  if [ "${use_ranger}" ]; then
    echo ""
    echo "Choosing a directory in Ranger is done by visiting a directory"
    echo ""
    echo "Use the arrow keys to browse folders"
    echo "Press 'Enter' to enter a directory"
    echo "Create a new directory with ':mkdir <dirname>'"
    echo ""
    echo "While in the directory you wish to select, quit Ranger with 'q'"
    echo ""
    while true; do
      read -p "Select directory now? (y/n) " answer
      case ${answer} in
        [Yy]*)
          FOLD="$(choose_folder)"
          echo ""
          echo "Selected directory = ${FOLD}"
          echo ""
          break
          ;;
        [Nn]*)
          printf "\nSkipping directory selection.\n"
          FOLD=
          break
          ;;
        *)
          echo "Please answer 'y' to select directory, or 'n' to skip."
          ;;
      esac
    done
  else
#   FOLD=$(dialog --stdout \
#                 --title "Please select an image input folder" \
#                 --fselect ${HOME}/ 14 48)
    printf "\nEnter the path to a directory\n"
    while true; do
      read -r -p "Enter directory path ('q' to exit): " foldpath
      [ "${foldpath}" == "q" ] && break
      if [ -d "${foldpath}" ]; then
        FOLD="${foldpath}"
        break
      else
        if [ "${foldpath}" ]; then
          printf "Specified directory ${foldpath} does not exist or is not a directory."
        else
          printf "\nEmpty directory path entered."
        fi
        printf "\nPlease enter a valid directory path or 'q' to exit this dialog.\n"
      fi
    done
  fi
}

set_haves() {
  have_gcc=$(type -p gcc)
  have_fzf=$(type -p fzf)
  have_figlet=$(type -p figlet)
  have_jq=$(type -p jq)
  have_lolcat=$(type -p lolcat)
  have_make=$(type -p make)
  have_ranger=$(type -p ranger)
  have_rich=$(type -p rich)
}

show_figlet() {
  if [ "$1" ]; then
    FIG_TEXT="$1"
  else
    FIG_TEXT="Kitty Control"
  fi
  # Seed random generator
  RANDOM=$$$(date +%s)
  USE_FONT=${fonts[$RANDOM % ${#fonts[@]}]}
  [ "${USE_FONT}" ] || USE_FONT="Standard"
  if [ "${have_lolcat}" ]; then
    figlet -c -d "${FONTDIR}" -f "${USE_FONT}" -k -t ${FIG_TEXT} 2>/dev/null | ${LOLCAT}
  else
    figlet -c -d "${FONTDIR}" -f "${USE_FONT}" -k -t ${FIG_TEXT} 2>/dev/null
  fi
}

show_usage() {
  figlet_text="Usage"
  while true; do
    clear_screen
    if [ "${use_figlet}" ]; then
      show_figlet "${figlet_text}"
    else
      [ "${have_rich}" ] && rich "[cyan]${figlet_text}[/cyan]" -p -a rounded -c -C
    fi
    brief_usage noexit
    show_versions
    options=("Examples" "Full Usage" "Main Menu" "Quit (q)")
    if [ "${use_fzf}" ]; then
      choice=$(printf "%s\n" "${options[@]}" | fzf --prompt="ðŸ˜º Select option ('Esc' or 'Main Menu' to return) ï˜½ " --height=8 --layout=reverse --exit-0)
      if [ "${choice}" ]; then
        case "${choice}" in
          Example*)
            show_examples noexit | less
            break
            ;;
          Full*)
            usage noexit | less
            break
            ;;
          Main* | "")
            break 2
            ;;
          Quit*)
            clear_screen
            printf "\nExiting kitty-control\n"
            exit 0
            ;;
          *)
            printf "\nCould not match '${choice}' with an entry."
            printf "\nPlease try again with an exact match.\n"
            break
            ;;
        esac
      else
        break 2
      fi
    else
      PS3="${BOLD}Enter a choice (number, shortcut, or text, 'h' help): ${NORM}"
      select opt in "${options[@]}"; do
        case "$opt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "Example"*,* | *,"Example"* | "example"*,* | *,"example"*)
          show_examples noexit | less
          break
          ;;
        "Full"*,* | *,"Full"* | "full"*,* | *,"full"*)
          usage noexit | less
          break
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          printf "\nCould not match '${REPLY}' with a menu entry."
          printf "\nPlease try again with an exact match.\n"
          break
          ;;
        esac
        REPLY=
      done
    fi
  done
}

prompt-color-input() {
  clear_screen
  if [ "${have_rich}" ]; then
    rich "Enter a supported color name or hex color code" -p
    rich "Supported color names:" -p
    rich "    [cyan]black white red green yellow blue magenta cyan[/]" -p
    rich "Hex color codes are of the form '[red]#120f3d[/]' (the '[red]#[/]' can be omitted)" -p
  else
    printf "\n\nEnter a supported color name or hex color code"
    printf "\nSupported color names:"
    printf "\n\tblack white red green yellow blue magenta cyan"
    printf "\nHex color codes are of the form '#120f3d' (the '#' can be omitted)\n"
  fi
}

prompt-match-input() {
  clear_screen
  if [ "${have_rich}" ]; then
    rich "[cyan]Tab/Window Matching Specification[/cyan]" -p -a rounded -c -C
  else
    if [ "${use_figlet}" ]; then
      show_figlet "Match Spec"
    else
      printf "\n\nTab/Window Matching Specification\n\n"
    fi
  fi
  printf "\n"
  if [ "${have_rich}" ]; then
    rich "Kitty remote control commands can be limited to matching tabs or windows" -p
    rich "by providing a specification that matches the tabs/windows you want to effect." -p
    printf "\n"
    rich "You can use [red]kitty-control list[/] to get a full list of tabs and windows" -p
    [ "${have_jq}" ] && {
      rich "Or [red]kitty-control ls[/] for an abbreviated list of windows" -p
    }
    printf "\n"
    rich "Match specifications are of the form: [red]field:query[/] where field can be one of:" -p
    rich "  [green]id index title window_id window_title pid cwd var state recent[/]" -p
    rich "[red]query[/] is the expression to match. Expressions can be either a number or a" -p
    rich "regular expression, and can be combined using Boolean operators." -p
    printf "\n"
    rich "The special value [red]all[/] matches all tabs/windows." -p
  else
    printf "\n\nKitty remote control commands can be limited to matching tabs or windows"
    printf "\nby providing a specification that matches the tabs/windows you want to effect."
    printf "\n\nYou can use 'kitty-control list' to get a full list of tabs and windows"
    [ "${have_jq}" ] && {
      printf "\nOr 'kitty-control ls' for an abbreviated list of windows"
    }
    printf "\n\nMatch specifications are of the form: 'field:query' where field can be one of:"
    printf "\n  id, index, title, window_id, window_title, pid, cwd, var, state and recent"
    printf "\n'query' is the expression to match. Expressions can be either a number or a"
    printf "\nregular expression, and can be combined using Boolean operators."
    printf "\n\nThe special value 'all' matches all tabs/windows.\n"
  fi
  printf "\n"
}

get_tabopts() {
  if [ "$1" ]; then
    tabop_return="$1"
  else
    tabop_return=
  fi
  while true; do
    read -r -p \
      "Enter tab matching specification ('q' to exit): " \
      -i "${tabop_return}" -e tabmatch
    [ "${tabmatch}" == "q" ] && break
    case ${tabmatch} in
      "-t "*)
        tabop_return=$(echo "${tabmatch}" | sed -e "s/-t //")
        break
        ;;
      "--match-tab "*)
        tabop_return=$(echo "${tabmatch}" | sed -e "s/--match-tab //")
        break
        ;;
      *)
        tabop_return="${tabmatch}"
        break
        ;;
    esac
  done
  echo "${tabop_return}"
}

get_winopts() {
  if [ "$1" ]; then
    winop_return="$1"
  else
    winop_return=
  fi
  while true; do
    read -r -p \
      "Enter window matching specification ('q' to exit): " \
      -i "${winop_return}" -e winmatch
    [ "${winmatch}" == "q" ] && break
    case ${winmatch} in
      "-t "*)
        winop_return=$(echo "${winmatch}" | sed -e "s/-t //")
        break
        ;;
      "--match "*)
        winop_return=$(echo "${winmatch}" | sed -e "s/--match //")
        break
        ;;
      *)
        winop_return="${winmatch}"
        break
        ;;
    esac
  done
  echo "${winop_return}"
}

get-color-input() {
  color_return=
  while true; do
    read -r -p "Enter color name/code ('q' to exit): " colorcode
    [ "${colorcode}" == "q" ] && break
    case ${colorcode} in
      black|white|red|green|yellow|blue|magenta|cyan)
        color_return="${colorcode}"
        break
        ;;
      "")
        printf "\nEmpty color. Enter a color name, code, or 'q'\n"
        prompt_continue
        ;;
      *)
        first_color=${colorcode::1}
        if [[ "${first_color}" == "#" ]]; then
          color_return="${colorcode}"
        else
          color_return="#${colorcode}"
        fi
        break
        ;;
    esac
  done
  echo "${color_return}"
}

list_tabs() {
  printf -v newline %b "\n"
  kitty @ ${SOCKET} ls ${OPTS} | jq -r '.[]?.tabs' | \
          jq -r '.[]' | \
          jq -r --color-output \
                --arg idpre "ID: " \
                --arg actpre "ACTIVE: " \
                --arg pidpre "PID: " \
                --arg titpre "TITLE: " \
                --arg tipost "$newline" \
                '$idpre + (.id|tostring), $actpre + (.is_active|tostring), $pidpre + (.pid|tostring), $titpre + .title + $tipost'
}

list_windows() {
  printf -v newline %b "\n"
  kitty @ ${SOCKET} ls ${OPTS} | jq -r '.[]?.tabs | .[]?.windows' | \
          jq -r '.[]' | \
          jq -r --color-output \
                --arg idpre "ID: " \
                --arg actpre "ACTIVE: " \
                --arg pidpre "PID: " \
                --arg titpre "TITLE: " \
                --arg tipost "$newline" \
                '$idpre + (.id|tostring), $actpre + (.is_active|tostring), $pidpre + (.pid|tostring), $titpre + .title + $tipost'
}

show_tab_info() {
  tab_id=$(echo "$1" | awk '{ print $2 }')
  [ "${tab_id}" ] && {
    [ "${debug}" ] && {
      printf "\nSelected Tab ID: ${tab_id}\n"
      printf "\nCommand: kitty @ ls | jq -r '.[]?.tabs | jq -r --arg tabid \"$tab_id\" '.[] | select((.id|tostring) == \$tabid)'\n"
      prompt_continue
    }
    if [ "${tab_id}" == "__all__" ]; then
      kitty @ ls | jq -r '.[]?.tabs' \
                 | jq -r --color-output '.[]' | less
    else
      kitty @ ls | jq -r '.[]?.tabs' \
                 | jq -r --color-output --arg tabid "$tab_id" '
                     .[] | select((.id|tostring) == $tabid)' | less
    fi
  }
}

show_window_info() {
  window_id=$(echo "$1" | awk '{ print $2 }')
  [ "${window_id}" ] && {
    [ "${debug}" ] && {
      printf "\nSelected Window ID: ${window_id}\n"
      printf "\nCommand: kitty @ ls | jq -r '.[]?.tabs | .[]?.windows' | jq -r --arg winid \"$window_id\" '.[] | select((.id|tostring) == \$winid)'\n"
      prompt_continue
    }
    if [ "${window_id}" == "__all__" ]; then
      kitty @ ls | jq -r '.[]?.tabs | .[]?.windows' \
                 | jq -r --color-output '.[]' | less
    else
      kitty @ ls | jq -r '.[]?.tabs | .[]?.windows' \
                 | jq -r --color-output --arg winid "$window_id" '
                     .[] | select((.id|tostring) == $winid)' | less
    fi
  }
}

tab_menu() {
  if [ "${have_jq}" ]; then
    tab_array=()
    printf -v newline %b "\n"
    while read id_title; do
      [ "${id_title}" ] || continue
      echo "${id_title}" | grep ID: >/dev/null && {
        entry="${id_title}"
      }
      echo "${id_title}" | grep TITLE: >/dev/null && {
        entry="${entry} ${id_title}"
        tab_array+=( "${entry}" )
      }
    done < <(kitty @ ls | jq -r '.[]?.tabs' | jq -r '.[]' | \
             jq -r --arg idpre "ID: " \
                   --arg titpre "TITLE: " \
                   --arg tipost "$newline" \
                   '$idpre + (.id|tostring), $titpre + .title + $tipost')

    tab_array+=( "All Tabs" "Help" "Main Menu" "Quit" )
    if [ "${use_fzf}" ]; then
      while true; do
        heading "Kitty Tabs List" "Kitty Tabs"
        choice=$(printf "%s\n" "${tab_array[@]}" | fzf --prompt="ðŸ˜º Select Tab ('Esc' or 'Main Menu' to return)  ï˜½ " --height=18 --layout=reverse --exit-0)
        if [ "${choice}" ]; then
          case "${choice}" in
            "Help")
              show_help
              ;;
            "Main"*)
              break
              ;;
            "Quit"*)
              clear_screen
              printf "\nExiting kitty-control\n"
              exit 0
              ;;
            "All Tabs"*)
              show_tab_info "ID: __all__"
              ;;
            *)
              show_tab_info "${choice}"
              ;;
          esac
        else
          break
        fi
      done
    else
      while true; do
        heading "Kitty Tabs List" "Kitty Tabs"
        PS3="${BOLD}Select Tab (number, shortcut, or text, 'h' help): ${NORM}"
        select subopt in "${tab_array[@]}"; do
          case "$subopt,$REPLY" in
          "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
            show_help
            break
            ;;
          "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
            break 2
            ;;
          "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
            clear_screen
            printf "\nExiting kitty-control\n"
            exit 0
            ;;
          "All Tabs"*,* | *,"All Tabs"* | "all tabs"*,* | *,"all tabs"*)
              show_tab_info "ID: __all__"
              ;;
          *,*)
            show_tab_info "${subopt}"
            break
            ;;
          esac
        done
      done
    fi
  else
    kitty @ ${SOCKET} ls ${OPTS} | less
  fi
}

windows_menu() {
  if [ "${have_jq}" ]; then
    win_array=()
    printf -v newline %b "\n"
    while read id_title; do
      [ "${id_title}" ] || continue
      echo "${id_title}" | grep ID: >/dev/null && {
        entry="${id_title}"
      }
      echo "${id_title}" | grep TITLE: >/dev/null && {
        entry="${entry} ${id_title}"
        win_array+=( "${entry}" )
      }
    done < <(kitty @ ls | jq -r '.[]?.tabs | .[]?.windows' | jq -r '.[]' | \
             jq -r --arg idpre "ID: " \
                   --arg titpre "TITLE: " \
                   --arg tipost "$newline" \
                   '$idpre + (.id|tostring), $titpre + .title + $tipost')

    win_array+=( "All Windows" "Help" "Main Menu" "Quit" )
    if [ "${use_fzf}" ]; then
      while true; do
        heading "Kitty Windows List" "Kitty Windows"
        choice=$(printf "%s\n" "${win_array[@]}" | fzf --prompt="ðŸ˜º Select Window ('Esc' or 'Main Menu' to return)  ï˜½ " --height=18 --layout=reverse --exit-0)
        if [ "${choice}" ]; then
          case "${choice}" in
            "Help")
              show_help
              ;;
            "Main"*)
              break
              ;;
            "Quit"*)
              clear_screen
              printf "\nExiting kitty-control\n"
              exit 0
              ;;
            "All Windows"*)
              show_window_info "ID: __all__"
              ;;
            *)
              show_window_info "${choice}"
              ;;
          esac
        else
          break
        fi
      done
    else
      while true; do
        heading "Kitty Windows List" "Kitty Windows"
        PS3="${BOLD}Select Window (number, shortcut, or text, 'h' help): ${NORM}"
        select subopt in "${win_array[@]}"; do
          case "$subopt,$REPLY" in
          "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
            show_help
            break
            ;;
          "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
            break 2
            ;;
          "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
            clear_screen
            printf "\nExiting kitty-control\n"
            exit 0
            ;;
          "All Windows"*,* | *,"All Windows"* | "all windows"*,* | *,"all windows"*)
              show_window_info "ID: __all__"
              ;;
          *,*)
            show_window_info "${subopt}"
            break
            ;;
          esac
        done
      done
    fi
  else
    kitty @ ${SOCKET} ls ${OPTS} | less
  fi
}

try_background() {
  color_choice="$1"
  forepre=$(kitty @ get-colors | grep "^foreground" | awk '{ print $2 }')
  backpre=$(kitty @ get-colors | grep "^background" | awk '{ print $2 }')
  set-background "${color_choice}"
  case "${color_choice}" in
    black)
      set-foreground white
      ;;
    white)
      set-foreground black
      ;;
    *)
      true
      ;;
  esac
  forecolor=$(kitty @ get-colors | grep "^foreground" | awk '{ print $2 }')
  backcolor=$(kitty @ get-colors | grep "^background" | awk '{ print $2 }')
  [ "${forecolor}" == "${backcolor}" ] && {
    set-foreground "${forepre}"
    set-background "${backpre}"
  }
}

try_foreground() {
  color_choice="$1"
  forepre=$(kitty @ get-colors | grep "^foreground" | awk '{ print $2 }')
  backpre=$(kitty @ get-colors | grep "^background" | awk '{ print $2 }')
  set-foreground "${color_choice}"
  forecolor=$(kitty @ get-colors | grep "^foreground" | awk '{ print $2 }')
  backcolor=$(kitty @ get-colors | grep "^background" | awk '{ print $2 }')
  [ "${forecolor}" == "${backcolor}" ] && {
    set-foreground "${forepre}"
    set-background "${backpre}"
  }
}

menu_background_color() {
  bgopts=( "${colors[@]}" )
  bgopts+=( "main menu" "quit" )
  if [ "${use_fzf}" ]; then
    heading "Background Color" "Background"
    choice=$(printf "%s\n" "${bgopts[@]}" | fzf --prompt="ðŸ˜º Select Background Color ('Esc' or 'main menu' to return) ï˜½ " --height=18 --layout=reverse --exit-0)
    [ "${choice}" ] && {
      case "${choice}" in
        "custom"*)
          prompt-color-input
          color_choice=$(get-color-input)
          [ "${color_choice}" ] && try_background "${color_choice}"
          break
          ;;
        "main"*)
          break
          ;;
        "reset"*)
          set-background reset
          break
          ;;
        "quit"*)
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *)
          try_background "${choice}"
          break
          ;;
      esac
    }
  else
    while true; do
      heading "Background Color" "Background"
      PS3="${BOLD}Select Background Color (number, shortcut, or text, 'h' help): ${NORM}"
      select subopt in "${bgopts[@]}"; do
        case "$subopt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "Custom",* | *,"Custom" | "custom",* | *,"custom")
          prompt-color-input
          color_choice=$(get-color-input)
          [ "${color_choice}" ] && try_background "${color_choice}"
          break 2
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Reset"*,* | *,"Reset"* | "reset"*,* | *,"reset"* | "r",* | *,"r")
          set-background reset
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          try_background "${subopt}"
          break 2
          ;;
        esac
      done
    done
  fi
}

menu_foreground_color() {
  fgopts=( "${colors[@]}" )
  fgopts+=( "main menu" "quit" )
  if [ "${use_fzf}" ]; then
    heading "Foreground Color" "Foreground"
    choice=$(printf "%s\n" "${fgopts[@]}" | fzf --prompt="ðŸ˜º Select Foreground Color ('Esc' or 'main menu' to return) ï˜½ " --height=18 --layout=reverse --exit-0)
    [ "${choice}" ] && {
      case "${choice}" in
        "custom"*)
          prompt-color-input
          color_choice=$(get-color-input)
          [ "${color_choice}" ] && try_foreground "${color_choice}"
          break
          ;;
        "main"*)
          break
          ;;
        "reset"*)
          set-foreground reset
          break
          ;;
        "quit"*)
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *)
          try_foreground "${choice}"
          break
          ;;
      esac
    }
  else
    while true; do
      heading "Foreground Color" "Foreground"
      PS3="${BOLD}Select Foreground Color (number, shortcut, or text, 'h' help): ${NORM}"
      select subopt in "${fgopts[@]}"; do
        case "$subopt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "Custom",* | *,"Custom" | "custom",* | *,"custom")
          prompt-color-input
          color_choice=$(get-color-input)
          [ "${color_choice}" ] && try_foreground "${color_choice}"
          break 2
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Reset"*,* | *,"Reset"* | "reset"*,* | *,"reset"* | "r",* | *,"r")
          set-foreground reset
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          try_foreground "${subopt}"
          break 2
          ;;
        esac
      done
    done
  fi
}

menu_diff_file() {
  FILE=
  file1=
  file2=
  select_file
  [ "${FILE}" ] && {
    file1="${FILE}"
    select_file
    [ "${FILE}" ] && {
      file2="${FILE}"
    }
  }
  [ "${file1}" ] && [ "${file2}" ] && {
    kitty +kitten diff "${file1}" "${file2}"
  }
}

menu_diff_folder() {
  FOLD=
  fold1=
  fold2=
  select_folder
  [ "${FOLD}" ] && {
    fold1="${FOLD}"
    select_folder
    [ "${FOLD}" ] && {
      fold2="${FOLD}"
    }
  }
  [ "${fold1}" ] && [ "${fold2}" ] && {
    kitty +kitten diff "${fold1}" "${fold2}"
  }
}

menu_font_size() {
  fnopts=( "${fontsizes[@]}" )
  fnopts+=( "main menu" "quit" )
  if [ "${use_fzf}" ]; then
    heading "Font Size" "Font Size"
    choice=$(printf "%s\n" "${fnopts[@]}" | fzf --prompt="ðŸ˜º Select Font Size Adjustment ('Esc' or 'main menu' to return) ï˜½ " --height=18 --layout=reverse --exit-0)
    [ "${choice}" ] && {
      case "${choice}" in
        "main"*)
          break
          ;;
        "default"*)
          kitty @ ${SOCKET} set-font-size ${OPTS} 0
          break
          ;;
        "quit"*)
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *)
          kitty-fontsize "${choice}"
          break
          ;;
      esac
    }
  else
    while true; do
      heading "Font Size" "Font Size"
      PS3="${BOLD}Select Font Size Adjustment (number, shortcut, or text, 'h' help): ${NORM}"
      select subopt in "${fnopts[@]}"; do
        case "$subopt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Default"*,* | *,"Default"* | "default"*,* | *,"default"* | "d",* | *,"d")
          kitty @ ${SOCKET} set-font-size ${OPTS} 0
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          kitty-fontsize "${subopt}"
          break 2
          ;;
        esac
      done
    done
  fi
}

menu_load_config() {
  cfopts=("$@")
  cfopts+=( "Help" "Main Menu" "Quit" )
  if [ "${use_fzf}" ]; then
    while true; do
      heading "Kitty Configuration" "Configuration"
      choice=$(printf "%s\n" "${cfopts[@]}" | fzf --prompt="ðŸ˜º Select Kitty Configuration ('Esc' or 'Main Menu' to return) ï˜½ " --height=16 --layout=reverse --exit-0)
      if [ "${choice}" ]; then
        case "${choice}" in
          "h" | "H" | "help" | "Help")
            show_help
            ;;
          "Main"* | "main"*)
            break
            ;;
          "Default"* | "default"* | "d")
            load-config "default"
            break
            ;;
          "Quit"* | "quit"* | "q")
            clear_screen
            printf "\nExiting kitty-control\n"
            exit 0
            ;;
          *)
            subdir=$(echo "${choice}" | awk -F '/' '{ printf $(NF - 1) }')
            subsub=$(echo "${choice}" | awk -F '/' '{ printf $(NF - 2)"/"$(NF - 1) }')
            load-config "${subdir}" "${subsub}"
            break
            ;;
        esac
      else
        break
      fi
    done
  else
    while true; do
      heading "Kitty Configuration" "Configuration"
      PS3="${BOLD}Select Kitty Configuration (number, shortcut, or text, 'h' help): ${NORM}"
      select subopt in "${cfopts[@]}"; do
        case "$subopt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Default"*,* | *,"Default"* | "default"*,* | *,"default"* | "d",* | *,"d")
          load-config "default"
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          subdir=$(echo "${subopt}" | awk -F '/' '{ printf $(NF - 1) }')
          subsub=$(echo "${subopt}" | awk -F '/' '{ printf $(NF - 2)"/"$(NF - 1) }')
          load-config "${subdir}" "${subsub}"
          break 2
          ;;
        esac
      done
    done
  fi
}

menu_set_trans() {
  tropts=( "${translevels[@]}" )
  tropts+=( "main menu" "quit" )
  if [ "${use_fzf}" ]; then
    heading "Transparency Opacity" "Transparency"
    choice=$(printf "%s\n" "${tropts[@]}" | fzf --prompt="ðŸ˜º Select Transparency Opacity ('Esc' or 'main menu' to return) ï˜½ " --height=18 --layout=reverse --exit-0)
    [ "${choice}" ] && {
      case "${choice}" in
        "default"*)
          set-opacity "${OPACITY}"
          ;;
        "main"*)
          break
          ;;
        "quit"*)
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *)
        set-opacity "${choice}"
        ;;
      esac
    }
  else
    while true; do
      heading "Transparency Opacity" "Transparency"
      PS3="${BOLD}Select Transparency Opacity (number, shortcut, or text, 'h' help): ${NORM}"
      select subopt in "${tropts[@]}"; do
        case "$subopt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "default"*,* | *,"default"*)
          set-opacity "${OPACITY}"
          break 2
          ;;
        [0-9].[0-9]*,* | *,[0-9].[0-9]*)
          set-opacity "${subopt}"
          break 2
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          printf "\nCould not match '${REPLY}' with a menu entry."
          printf "\nPlease try again with an exact match.\n"
          break
          ;;
        esac
        REPLY=
      done
    done
  fi
}

options_menu() {
  while true; do
    clear_screen
    if [ "${have_rich}" ]; then
      rich "[cyan]Kitty Control Options Menu[/cyan]" -p -a rounded -c -C
    else
      if [ "${use_figlet}" ]; then
        show_figlet "Options Menu"
      else
        printf "\n\nKitty Control Options Menu\n\n"
      fi
    fi
    printf "\n"
    kc_options=()
    if [ "${allopt}" ]; then
      kc_options+=("All Tabs/Windows  [yes]")
    else
      kc_options+=("All Tabs/Windows  [no]")
    fi
    kc_options+=("Tab Match Spec    [${tabopts}]")
    kc_options+=("Window Match Spec [${winopts}]")
    if [ "${debug}" ]; then
      kc_options+=("Debug Mode        [yes]")
    else
      kc_options+=("Debug Mode        [no]")
    fi
    [ "${have_figlet}" ] && {
      if [ "${use_figlet}" ]; then
        kc_options+=("Use Figlet        [yes]")
      else
        kc_options+=("Use Figlet        [no]")
      fi
    }
    [ "${have_fzf}" ] && {
      if [ "${use_fzf}" ]; then
        kc_options+=("Use Fzf           [yes]")
      else
        kc_options+=("Use Fzf           [no]")
      fi
    }
    [ "${have_ranger}" ] && {
      if [ "${use_ranger}" ]; then
        kc_options+=("Use Ranger        [yes]")
      else
        kc_options+=("Use Ranger        [no]")
      fi
    }
    kc_options+=("Help" "Main Menu" "Quit (q)")
    if [ "${use_fzf}" ]; then
      choice=$(printf "%s\n" "${kc_options[@]}" | fzf --prompt="ðŸ˜º Set/Toggle Options ('Esc' or 'Main Menu' to return) ï˜½ " --height=18 --layout=reverse --exit-0)
      if [ "${choice}" ]; then
        case "${choice}" in
          "h" | "H" | "help" | "Help")
            show_help
            ;;
          "All"* | "all"*)
            if [ "${allopts}" ]; then
              OPTS=$(echo "${OPTS}" | sed -e "s/ -a//")
              allopts=
            else
              OPTS="${OPTS} -a"
              allopts=1
            fi
            ;;
          "Debug"* | "debug"*)
            if [ "${debug}" ]; then
              debug=
            else
              debug=1
            fi
            ;;
          "Tab"* | "tab"*)
            if [ "${tabopts}" ]; then
              OPTS=$(echo "${OPTS}" | sed -e "s/ -t ${tabopts}//")
              prompt-match-input
              tabopts=$(get_tabopts "${tabopts}")
              [ "${tabopts}" ] && OPTS="${OPTS} -t ${tabopts}"
            else
              prompt-match-input
              tabopts=$(get_tabopts)
              [ "${tabopts}" ] && OPTS="${OPTS} -t ${tabopts}"
            fi
            ;;
          "Window"* | "window"*)
            if [ "${winopts}" ]; then
              OPTS=$(echo "${OPTS}" | sed -e "s/ -m ${winopts}//")
              prompt-match-input
              winopts=$(get_winopts "${winopts}")
              [ "${winopts}" ] && OPTS="${OPTS} -m ${winopts}"
            else
              prompt-match-input
              winopts=$(get_winopts)
              [ "${winopts}" ] && OPTS="${OPTS} -m ${winopts}"
            fi
            ;;
          "Use Figlet"* | "use figlet"*)
            if [ "${use_figlet}" ]; then
              use_figlet=
            else
              use_figlet=1
            fi
            ;;
          "Use Fzf"* | "use fzf"*)
            if [ "${use_fzf}" ]; then
              use_fzf=
            else
              use_fzf=1
            fi
            ;;
          "Use Ranger"* | "use ranger"*)
            if [ "${use_ranger}" ]; then
              use_ranger=
            else
              use_ranger=1
            fi
            ;;
          Main*)
            break
            ;;
          Quit*)
            clear_screen
            printf "\nExiting kitty-control\n"
            exit 0
            ;;
          *)
            printf "\nCould not match '${choice}' with an entry."
            printf "\nPlease try again with an exact match.\n"
            ;;
        esac
      else
        break
      fi
    else
      PS3="${BOLD}Enter a choice (number, shortcut, or text, 'h' help): ${NORM}"
      select opt in "${kc_options[@]}"; do
        case "$opt,$REPLY" in
        "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
          show_help
          break
          ;;
        "All"*,* | *,"All"* | "all"*,* | *,"all"*)
          if [ "${allopts}" ]; then
            OPTS=$(echo "${OPTS}" | sed -e "s/ -a//")
            allopts=
          else
            OPTS="${OPTS} -a"
            allopts=1
          fi
          break
          ;;
        "Debug"*,* | *,"Debug"* | "debug"*,* | *,"debug"*)
          if [ "${debug}" ]; then
            debug=
          else
            debug=1
          fi
          break
          ;;
        "Tab"*,* | *,"Tab"* | "tab"*,* | *,"tab"*)
          if [ "${tabopts}" ]; then
            OPTS=$(echo "${OPTS}" | sed -e "s/ -t ${tabopts}//")
            prompt-match-input
            tabopts=$(get_tabopts "${tabopts}")
            [ "${tabopts}" ] && OPTS="${OPTS} -t ${tabopts}"
          else
            prompt-match-input
            tabopts=$(get_tabopts)
            [ "${tabopts}" ] && OPTS="${OPTS} -t ${tabopts}"
          fi
          break
          ;;
        "Win"*,* | *,"Win"* | "win"*,* | *,"win"*)
          if [ "${winopts}" ]; then
            OPTS=$(echo "${OPTS}" | sed -e "s/ -m ${winopts}//")
            prompt-match-input
            winopts=$(get_winopts "${winopts}")
            [ "${winopts}" ] && OPTS="${OPTS} -m ${winopts}"
          else
            prompt-match-input
            winopts=$(get_winopts)
            [ "${winopts}" ] && OPTS="${OPTS} -m ${winopts}"
          fi
          break
          ;;
        "Use Figlet"*,* | *,"Use Figlet"* | "use figlet"*,* | *,"use figlet"*)
          if [ "${use_figlet}" ]; then
            use_figlet=
          else
            use_figlet=1
          fi
          break
          ;;
        "Use Fzf"*,* | *,"Use Fzf"* | "use fzf"*,* | *,"use fzf"*)
          if [ "${use_fzf}" ]; then
            use_fzf=
          else
            use_fzf=1
          fi
          break
          ;;
        "Use Ranger"*,* | *,"Use Ranger"* | "use ranger"*,* | *,"use ranger"*)
          if [ "${use_ranger}" ]; then
            use_ranger=
          else
            use_ranger=1
          fi
          break
          ;;
        "Main"*,* | *,"Main"* | "main"*,* | *,"main"*)
          break 2
          ;;
        "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *,*)
          printf "\nCould not match '${REPLY}' with a menu entry."
          printf "\nPlease try again with an exact match.\n"
          break
          ;;
        esac
        REPLY=
      done
    fi
  done
}

select_with_fzf() {
  fzopts=("$@")
  fzopts+=( "Help" "Main Menu" )
  while true; do
    clear_screen
    heading "Kitty Control" "Kitty Control"
    choice=$(printf "%s\n" "${fzopts[@]}" | fzf -m --prompt="ðŸ˜º Select Menu Option ('Main Menu' or 'Esc' to return) ï˜½ " --height=18 --layout=reverse --exit-0)
    if [ "${choice}" ]; then
      case "${choice}" in
        "h" | "H" | "help"* | "Help"*)
          show_help
          ;;
        "Main"* | "main"*)
          break
          ;;
        "reset"*)
          set-foreground reset
          ;;
        "Background Color"* | "bg" | "back")
          menu_background_color
          ;;
        "Foreground Color"* | "fg" | "fore")
          menu_foreground_color
          ;;
        "Background Image")
          FILE=
          select_file image
          [ "${FILE}" ] && set-bg-image "${FILE}"
          ;;
        "Clear"* | "clear"* | "c")
          set-bg-image none
          ;;
        "Dark"* | "dark"* | "d" | "d")
          set-opacity "1.0"
          ;;
        "Diff File"* | "diff file"*)
          menu_diff_file
          ;;
        "Diff Fold"* | "diff fold"*)
          menu_diff_folder
          ;;
        "Exam"* | "exam"*)
          show_examples noexit | less
          ;;
        "Font"* | "font"* | "f")
          menu_font_size
          ;;
        "Install Figlet")
          install_figlet
          ;;
        "Install Fzf")
          install_fzf
          ;;
        "Install Ranger")
          install_ranger
          ;;
        "List Tab"* | "list tab"* | "K")
          tab_menu
          ;;
        "List Win"* | "list win"* | "L")
          windows_menu
          ;;
        "Load"* | "load"* | "l")
          numconfs=1
          configs=("default")
          for kconf in ${CONFDIR}/*/kitty.conf ${CONFDIR}/*/*/kitty.conf
          do
            [ "${kconf}" == "${CONFDIR}/*/kitty.conf" ] && continue
            [ "${kconf}" == "${CONFDIR}/*/*/kitty.conf" ] && continue
            ((numconfs++))
            configs+=("${kconf}")
          done
          menu_load_config "${configs[@]}"
          ;;
        "View"* | "view"* | "v")
          FILE=
          select_file image
          [ "${FILE}" ] && {
            kitty +kitten icat ${FILE}
            printf "\nTo view this image use: kitty +kitten icat ${FILE}\n"
            prompt_continue
          }
          ;;
        "Theme"* | "theme"* | "T")
          kitty +kitten themes
          ;;
        "Term"* | "term"* | "info" | "i")
          printf "\n"
          kitty +kitten query_terminal
          prompt_continue
          ;;
        "Tran"* | "tran"* | "t")
          menu_set_trans
          ;;
        "Toggle"* | "toggle"* | "full" | "F")
          toggle-fullscreen
          sleep 1
          ;;
        "Unicode"* | "unicode"*)
          kitty +kitten unicode_input
          ;;
        "Show"* | "show"*)
          show_usage usage
          ;;
        "Manual"* | "manual"*)
          printf "\n"
          man kitty-control
          ;;
        "Opt"* | "opt"* | "o")
          options_menu
          ;;
        "Upgrade kitty-control"* | "upgrade kitty-control"*)
          upgrade_kitty_control noexit
          ;;
        "Upgrade Kitty"* | "upgrade kitty"*)
          install_kitty
          ;;
        "Upgrade Fzf"* | "upgrade fzf"*)
          upgrade_fzf
          ;;
        "Quit"* | "quit"* | "Q" | "q")
          clear_screen
          printf "\nExiting kitty-control\n"
          exit 0
          ;;
        *)
          printf "\nCould not match '${choice}' with a menu entry."
          printf "\nPlease try again with an exact match.\n"
          ;;
      esac
    else
      break
    fi
  done
}

show_menu() {
  set_haves
  while true; do
    clear_screen
    if [ "${use_figlet}" ]; then
      show_figlet
    else
      [ "${have_rich}" ] && rich "[cyan]Kitty Control[/cyan]" -p -a rounded -c -C
    fi
    printf "\n"
    options=()
    PS3="${BOLD}Enter a choice (number, shortcut, or text, 'h' help): ${NORM}"
    numconfs=1
    configs=("default")
    for kconf in ${CONFDIR}/*/kitty.conf ${CONFDIR}/*/*/kitty.conf
    do
      [ "${kconf}" == "${CONFDIR}/*/kitty.conf" ] && continue
      [ "${kconf}" == "${CONFDIR}/*/*/kitty.conf" ] && continue
      ((numconfs++))
      configs+=("${kconf}")
    done
    options+=("Background Color" "Background Image" "Clear Background")
    options+=("Dark/Opaque" "Diff Files" "Diff Folders" "Examples" "Font Size")
    options+=("Foreground Color")
    [ "${have_figlet}" ] || options+=("Install Figlet")
    [ "${have_fzf}" ] || options+=("Install Fzf")
    [ "${have_ranger}" ] || options+=("Install Ranger")
    options+=("List Tabs")
    options+=("List Windows")
    [ ${numconfs} -gt 1 ] && {
      options+=("Load Configuration")
    }
    options+=("Manual Page" "Options" "Show Usage/Version" "Theme Selection")
    options+=("Terminal Info" "Toggle Fullscreen" "Transparent" "Unicode Input")
    [ "${have_fzf}" ] && {
      fzf_release_version=$(curl -fsSL "${fzf_url}" | grep ^version= | awk -F '=' '{ print $2 }')
      fzf_install_version=$(fzf --version | awk '{ print $1 }')
      update_fzf=$(check_three_version "${fzf_release_version}" "${fzf_install_version}")
      [ "${update_fzf}" ] && {
        options+=("Upgrade Fzf (${fzf_install_version} -> ${fzf_release_version})")
      }
    }
    release_version=$(curl -fsSL "${kitty_version_url}")
    install_version=$(kitty --version | awk '{ print $2 }')
    update_kitty=$(check_three_version "${release_version}" "${install_version}")
    [ "${update_kitty}" ] && {
      options+=("Upgrade Kitty (${install_version} -> ${release_version})")
    }
    control_version=$(get_control_version)
    install_version=$(get_install_version)
    update_control=$(check_control_version "${control_version}" "${install_version}")
    [ "${update_control}" ] && {
      options+=("Upgrade kitty-control (${install_version} -> ${control_version})")
    }
    options+=("View an Image" "Quit (q)")
    set_show_shortcuts
    select opt in "${options[@]}"; do
      case "$opt,$REPLY" in
      "h",* | *,"h" | "H",* | *,"H" | "help",* | *,"help" | "Help",* | *,"Help")
        show_help
        break
        ;;
      "Background Color",* | *,"Background Color" | "bg",* | *,"bg" | "back",* | *,"back")
        menu_background_color
        break
        ;;
      "Foreground Color",* | *,"Foreground Color" | "fg",* | *,"fg" | "fore",* | *,"fore")
        menu_foreground_color
        break
        ;;
      "Background Image",* | *,"Background Image")
        FILE=
        select_file image
        [ "${FILE}" ] && set-bg-image "${FILE}"
        break
        ;;
      "Clear"*,* | *,"Clear"* | "clear"*,* | *,"clear"* | "c",* | *,"c")
        set-bg-image none
        break
        ;;
      "Dark"*,* | *,"Dark"* | "dark"*,* | *,"dark"* | "d",* | *,"d")
        set-opacity "1.0"
        break
        ;;
      "Diff File"*,* | *,"Diff File"* | "diff file"*,* | *,"diff file"*)
        menu_diff_file
        break
        ;;
      "Diff Fold"*,* | *,"Diff Fold"* | "diff fold"*,* | *,"diff fold"*)
        menu_diff_folder
        break
        ;;
      "Exam"*,* | *,"Exam"* | "exam"*,* | *,"exam"*)
        show_examples noexit | less
        break
        ;;
      "Font"*,* | *,"Font"* | "font"*,* | *,"font"* | "f",* | *,"f")
        menu_font_size
        break
        ;;
      "Fzf",* | *,"Fzf" | "fzf",* | *,"fzf" | "Fuzzy",* | *,"Fuzzy" | "fuzzy",* | *,"fuzzy")
        [ "${have_fzf}" ] && select_with_fzf "${options[@]}"
        break
        ;;
      "Install Figlet",* | *,"Install Figlet")
        install_figlet
        break
        ;;
      "Install Fzf",* | *,"Install Fzf")
        install_fzf
        break
        ;;
      "Install Ranger",* | *,"Install Ranger")
        install_ranger
        break
        ;;
      "List Tab"*,* | *,"List Tab"* | "list tab"*,* | *,"list tab"* | "K",* | *,"K")
        tab_menu
        break
        ;;
      "List Win"*,* | *,"List Win"* | "list win"*,* | *,"list win"* | "L",* | *,"L")
        windows_menu
        break
        ;;
      "Load"*,* | *,"Load"* | "load"*,* | *,"load"* | "l",* | *,"l")
        menu_load_config "${configs[@]}"
        break
        ;;
      "View"*,* | *,"View"* | "view"*,* | *,"view"* | "v",* | *,"v")
        FILE=
        select_file image
        [ "${FILE}" ] && {
          kitty +kitten icat ${FILE}
          printf "\nTo view this image use: kitty +kitten icat ${FILE}\n"
          prompt_continue
        }
        break
        ;;
      "Theme"*,* | *,"Theme"* | "theme"*,* | *,"theme"* | "T",* | *,"T")
        kitty +kitten themes
        break
        ;;
      "Term"*,* | *,"Term"* | "term"*,* | *,"term"* | "info",* | *,"info" | "i",* | *,"i")
        printf "\n"
        kitty +kitten query_terminal
        prompt_continue
        break
        ;;
      "Tran"*,* | *,"Tran"* | "tran"*,* | *,"tran"* | "t",* | *,"t")
        menu_set_trans
        break
        ;;
      "Toggle"*,* | *,"Toggle"* | "toggle"*,* | *,"toggle"* | "full",* | *,"full" | "F",* | *,"F")
        toggle-fullscreen
        sleep 1
        break
        ;;
      "Unicode"*,* | *,"Unicode"* | "unicode"*,* | *,"unicode"*)
        kitty +kitten unicode_input
        break
        ;;
      "Show"*,* | *,"Show"* | "show"*,* | *,"show"*)
        show_usage usage
        break
        ;;
      "Manual"*,* | *,"Manual"* | "manual"*,* | *,"manual"*)
        printf "\n"
        man kitty-control
        break
        ;;
      "Opt"*,* | *,"Opt"* | "opt"*,* | *,"opt"* | "o",* | *,"o")
        options_menu
        break
        ;;
      "Upgrade kitty-control"*,* | *,"Upgrade kitty-control"* | "upgrade kitty-control"*,* | *,"upgrade kitty-control"*)
        upgrade_kitty_control noexit
        break
        ;;
      "Upgrade Kitty"*,* | *,"Upgrade Kitty"* | "upgrade kitty"*,* | *,"upgrade kitty"*)
        install_kitty
        break
        ;;
      "Upgrade Fzf"*,* | *,"Upgrade Fzf"* | "upgrade fzf"*,* | *,"upgrade fzf"*)
        upgrade_fzf
        break
        ;;
      "Quit"*,* | *,"Quit"* | "quit"*,* | *,"quit"* | "q",* | *,"q")
        clear_screen
        printf "\nExiting kitty-control\n"
        exit 0
        ;;
      *,*)
        printf "\nCould not match '${REPLY}' with a menu entry."
        printf "\nPlease try again with an exact match.\n"
        break
        ;;
      esac
      REPLY=
    done
  done
}

## Main execution starts here
#
uid=$(id -u)
gid=$(id -g)
SUDO="sudo -E"
if [ "${EUID}" ]; then
  [ ${EUID} -eq 0 ] && SUDO=
else
  [ ${uid} -eq 0 ] && SUDO=
fi
[ -d ${HOME}/.local/bin ] && pathadd "${HOME}/.local/bin"
[ -d ${HOME}/.fzf/bin ] && pathadd "${HOME}/.fzf/bin"
have_kitty=$(type -p kitty)
[ "${have_kitty}" ] || {
  install_kitty
  have_kitty=$(type -p kitty)
  [ "${have_kitty}" ] || {
    printf "\n\nERROR: kitty not found"
    printf "\nInstall kitty and re-run kitty-control. Exiting.\n"
    exit 1
  }
}
have_fzf=$(type -p fzf)
[ "${have_fzf}" ] || install_fzf

# Check for new load-config-file Kitty command
USE_LOAD_CONFIG=
if kitty @ ${SOCKET} load-config-file 2>/dev/null; then
  USE_LOAD_CONFIG=1
fi

# Menu tools
use_figlet=1
use_fzf=1
use_ranger=1
set_haves
[ "${have_figlet}" ] || use_figlet=
[ "${have_fzf}" ] || use_fzf=
[ "${have_ranger}" ] || use_ranger=
[ "$1" ] || show_menu

# Some actions need to be delayed until after any configuration load
allopt=
bg_image=
backgrnd=
debug=
foregrnd=
fontplus=
fontdown=
fontsize=
fullscrn=
install_version=
release_version=
kittycmd=
setopcty=
set_menu=
tabopts=
winopts=
while [[ $1 ]]; do
  case "$1" in
    -a | --all)
      OPTS="${OPTS} -a"
      allopt=1
      shift
      ;;
    -c | --command)
      kittycmd="$2"
      shift 2
      ;;
    -i | --image)
      bg_image="$2"
      shift 2
      ;;
    -f | --fullscreen)
      fullscrn=1
      shift
      ;;
    -m | --match)
      if [ "$2" == "--help" ]; then
        printf "\nSee https://sw.kovidgoyal.net/kitty/remote-control/#matching-windows-and-tabs\n\n"
        exit 0
      else
        winopts="$2"
        OPTS="${OPTS} -m ${winopts}"
      fi
      shift 2
      ;;
    -s | --socket)
      if [ "$2" == "--help" ]; then
        printf "\nStart kitty as:"
        printf "\n\tkitty -o allow_remote_control=yes --listen-on unix:/tmp/mykitty"
        printf "\nThe kitty '--listen-on' option tells kitty to listen for control messages"
        printf "\nat the specified UNIX-domain socket. See kitty --help for details.\n"
        printf "\nNow you can control this instance of kitty using the"
        printf "\n\tkitten @ --to command line argument to kitten @. For example:"
        printf "\n\tkitten @ --to unix:/tmp/mykitty ls"
        printf "\nRemote control via a socket can be enabled in kitty.conf by setting:"
        printf "\n\tallow_remote_control yes"
        printf "\n\tlisten_on unix:/tmp/mykitty\n"
        printf "\nTo use this with kitty-control invoke with '-s /tmp/mykitty'."
        printf "\nFor example: kitty-control -s /tmp/mykitty fontsize 24"
        printf "\nThis would send the font size command to the Kitty instance"
        printf "\nlistening on the unix domain socket at /tmp/mykitty\n\n"
        exit 0
      else
        [ -S "$2" ] && SOCKET="--to unix:$2"
      fi
      shift 2
      ;;
    -t | --tab)
      if [ "$2" == "--help" ]; then
        printf "\nSee https://sw.kovidgoyal.net/kitty/remote-control/#matching-windows-and-tabs\n\n"
        exit 0
      else
        tabopts="$2"
        OPTS="${OPTS} -t ${tabopts}"
      fi
      shift 2
      ;;
    -d | --debug)
      debug=1
      shift
      ;;
    -e | --examples)
      show_examples
      shift
      ;;
    -E | --Examples)
      BOLD=
      NORM=
      show_examples
      shift
      ;;
    -h | --help)
      usage
      shift
      ;;
    -H | --Help)
      BOLD=
      NORM=
      usage
      shift
      ;;
    -u | --usage)
      brief_usage
      shift
      ;;
    -v | --version)
      show_versions
      exit 0
      ;;
    back*|--back*)
      if [ "$2" ]; then
        backgrnd="$2"
        shift 2
      else
        printf "\nERROR: background keyword requires an argument"
        brief_usage
      fi
      ;;
    fore*|--fore*)
      if [ "$2" ]; then
        foregrnd="$2"
        shift 2
      else
        printf "\nERROR: foreground keyword requires an argument"
        brief_usage
      fi
      ;;
    diff|--diff)
      if [ "$2" ] && [ "$3" ]; then
        kitty +kitten diff $2 $3
        shift 3
      else
        printf "\nERROR: diff keyword requires two file or directory arguments"
        brief_usage
      fi
      ;;
    icat|--icat)
      if [ "$2" ]; then
        kitty +kitten icat $2
        shift 2
      else
        printf "\nERROR: icat keyword requires an image as argument"
        brief_usage
      fi
      ;;
    list|--list)
      [ "$2" == "self" ] && {
        OPTS="--self ${OPTS}"
        shift
      }
      if [ "${have_jq}" ]; then
        kitty @ ${SOCKET} ls ${OPTS} | jq --color-output '.[]'
      else
        kitty @ ${SOCKET} ls ${OPTS}
      fi
      shift
      ;;
    ls|--ls)
      [ "$2" == "self" ] && {
        OPTS="--self ${OPTS}"
        shift
      }
      if [ "${have_jq}" ]; then
        list_windows
      else
        kitty @ ${SOCKET} ls ${OPTS}
      fi
      shift
      ;;
    load|reload|--load|--reload)
      if [ "$2" ]; then
        load-config "$2"
        shift 2
      else
        load-config "${CONFDIR}/kitty.conf"
        shift
      fi
      ;;
    dark|opaque|--dark|--opaque)
      setopcty="1.0"
      shift
      ;;
    fontmin*|fontdec*|--fontmin*|--fontdec*)
      if [ "$2" ]; then
        fontdown="$2"
        shift 2
      else
        fontdown=1
        shift
      fi
      ;;
    fontplus|fontinc*|--fontplus|--fontinc*)
      if [ "$2" ]; then
        fontplus="$2"
        shift 2
      else
        fontplus=1
        shift
      fi
      ;;
    font*|--font*)
      if [ "$2" ]; then
        fontsize="$2"
        shift 2
      else
        fontsize="0"
        shift
      fi
      ;;
    man|--man)
      man kitty-control
      shift
      ;;
    menu|--menu)
      set_menu=1
      shift
      ;;
    title|--title)
      if [ "$2" ]; then
        kitty @ ${SOCKET} set-tab-title ${OPTS} "$2"
        shift 2
      else
        printf "\nERROR: title keyword requires an argument"
        brief_usage
      fi
      ;;
    opacity|tran*|--opacity|--tran*)
      if [ "$2" ]; then
        OPACITY="$2"
        shift 2
      else
        shift
      fi
      setopcty="${OPACITY}"
      ;;
    term*|--term*)
      kitty +kitten query_terminal
      shift
      ;;
    theme*|--theme*)
      kitty +kitten themes
      shift
      ;;
    tool*|--tool*)
      set_haves
      if [ "${have_make}" ]; then
        [ "${have_figlet}" ] || {
          if [ "${have_gcc}" ]; then
            install_figlet
          else
            printf "\nInstallation of figlet requires 'gcc' but 'gcc' not found."
          fi
        }
        [ "${have_ranger}" ] || install_ranger
      else
        printf "\nInstallation of tools requires 'make' but 'make' not found."
      fi
      ;;
    unicode|--unicode)
      kitty +kitten unicode_input
      shift
      ;;
    upgrade|--upgrade)
      if [ "${have_fzf}" ]; then
        fzf_release_version=$(curl -fsSL "${fzf_url}" | grep ^version= | awk -F '=' '{ print $2 }')
        fzf_install_version=$(fzf --version | awk '{ print $1 }')
        update_fzf=$(check_three_version "${fzf_release_version}" "${fzf_install_version}")
        if [ "${update_fzf}" ]; then
          upgrade_fzf
        else
          printf "\nInstalled version of Fzf is current âœ¨ ðŸŒŸ âœ¨\n"
        fi
      else
        install_fzf
      fi
      release_version=$(curl -fsSL "${kitty_version_url}")
      install_version=$(kitty --version | awk '{ print $2 }')
      update_kitty=$(check_three_version "${release_version}" "${install_version}")
      if [ "${update_kitty}" ]; then
        install_kitty
      else
        printf "\nInstalled version of Kitty is current âœ¨ ðŸŒŸ âœ¨\n"
      fi
      control_version=$(get_control_version)
      install_version=$(get_install_version)
      update_control=$(check_control_version "${control_version}" "${install_version}")
      if [ "${update_control}" ]; then
        upgrade_kitty_control
      else
        printf "\nInstalled version of kitty-control is current âœ¨ ðŸŒŸ âœ¨\n"
      fi
      shift
      ;;
    *)
      printf "\nUnsupported Kitty control command: $1"
      usage
      ;;
  esac
done

# These needed to be delayed until after any configuration loading
[ "${fontplus}" ] && kitty-fontplus "${fontplus}"
[ "${fontdown}" ] && kitty-fontminus "${fontdown}"
[ "${fontsize}" ] && kitty-fontsize "${fontsize}"
[ "${backgrnd}" ] && set-background "${backgrnd}"
[ "${foregrnd}" ] && set-foreground "${foregrnd}"
[ "${fullscrn}" ] && toggle-fullscreen
[ "${setopcty}" ] && set-opacity "${setopcty}"
[ "${bg_image}" ] && set-bg-image "${bg_image}"
[ "${kittycmd}" ] && kitty @ ${SOCKET} ${kittycmd} ${OPTS}
[ "${set_menu}" ] && show_menu
